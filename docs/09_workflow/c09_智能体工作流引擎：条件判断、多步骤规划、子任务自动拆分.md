# ç¬¬9ç«  æ™ºèƒ½ä½“å·¥ä½œæµå¼•æ“ï¼šæ¡ä»¶åˆ¤æ–­ã€å¤šæ­¥éª¤è§„åˆ’ã€å­ä»»åŠ¡è‡ªåŠ¨æ‹†åˆ†
## 9.1 æœ¬ç« æ ¸å¿ƒä»·å€¼
å‰8ç« å·²ç»å®ç°ï¼š
- ç»“æ„åŒ–é•¿æœŸè®°å¿†
- å¤–éƒ¨çŸ¥è¯†åº“ï¼ˆPDF/MD/TXTï¼‰RAG
- åŸºç¡€å·¥å…·è°ƒç”¨ï¼ˆè®¡ç®—ã€å¤©æ°”ã€æœç´¢ï¼‰
- ç®€å•ä»»åŠ¡è§„åˆ’

ä½†ä»å­˜åœ¨**å†³ç­–èƒ½åŠ›å¼±ã€æµç¨‹ä¸å¯æ§ã€å¤æ‚ä»»åŠ¡æ— æ³•è‡ªåŠ¨æ‹†è§£**çš„é—®é¢˜ã€‚

æœ¬ç« ç›®æ ‡ï¼š
**æ‰“é€ ä¸€ä¸ªçœŸæ­£èƒ½â€œæ€è€ƒâ€”è§„åˆ’â€”æ‰§è¡Œâ€”åæ€â€çš„æ™ºèƒ½ä½“å·¥ä½œæµå¼•æ“ï¼Œæ”¯æŒï¼š**
1. æ„å›¾è¯†åˆ«ï¼šåˆ¤æ–­ç”¨æˆ·è¦åšä»€ä¹ˆ
2. æ¡ä»¶åˆ¤æ–­ï¼šæ ¹æ®ä¸Šä¸‹æ–‡è‡ªåŠ¨é€‰æ‹©èƒ½åŠ›
3. å¤šæ­¥éª¤ä»»åŠ¡è‡ªåŠ¨æ‹†åˆ†
4. å­ä»»åŠ¡è°ƒåº¦ä¸æ‰§è¡Œ
5. æ‰§è¡Œç»“æœåæ€ä¸ä¿®æ­£
6. ä¸è®°å¿†ã€çŸ¥è¯†åº“ã€å·¥å…·å…¨é“¾è·¯æ‰“é€š

---

## 9.2 å·¥ä½œæµå¼•æ“æ•´ä½“æ¶æ„
```
ç”¨æˆ·è¾“å…¥
   â†“
æ„å›¾è¯†åˆ«ï¼ˆIntentClassifierï¼‰â†’ åˆ†ç±»ï¼šèŠå¤© / çŸ¥è¯†é—®ç­” / å·¥å…·è°ƒç”¨ / å¤æ‚ä»»åŠ¡
   â†“
ä»»åŠ¡è§„åˆ’ï¼ˆTaskPlannerï¼‰â†’ æ‹†åˆ†å­æ­¥éª¤ã€åˆ¤æ–­æ˜¯å¦éœ€è¦çŸ¥è¯†åº“/å·¥å…·/è®°å¿†
   â†“
æ¡ä»¶è·¯ç”±ï¼ˆConditionRouterï¼‰â†’ èµ°èŠå¤© / RAG / å·¥å…·é“¾ / å·¥ä½œæµ
   â†“
æ‰§è¡Œå™¨ï¼ˆExecutorï¼‰â†’ è°ƒç”¨å·¥å…·ã€æŸ¥è¯¢çŸ¥è¯†åº“ã€æ‰§è¡Œå­ä»»åŠ¡
   â†“
åæ€æ ¡éªŒï¼ˆReflectorï¼‰â†’ æ£€æŸ¥ç»“æœæ˜¯å¦åˆç†ã€æ˜¯å¦éœ€è¦é‡è·‘
   â†“
ç»“æ„åŒ–è®°å¿† â†’ ä¿å­˜æµç¨‹ä¸ç»“æœ
   â†“
è¿”å›æœ€ç»ˆå›ç­”
```

---

## 9.3 æ ¸å¿ƒæ¨¡å—è®¾è®¡ï¼ˆå¯ç›´æ¥åµŒå…¥å·¥ç¨‹ï¼‰

### 9.3.1 æ„å›¾è¯†åˆ«æ¨¡å—
```python
# intent_classifier.py
import json
from config import DASHSCOPE_API_KEY
from dashscope import Generation

class IntentClassifier:
    def __init__(self):
        self.api_key = DASHSCOPE_API_KEY

    def classify(self, user_input):
        prompt = f"""
ä½ æ˜¯æ„å›¾è¯†åˆ«å™¨ï¼Œåˆ¤æ–­ç”¨æˆ·è¾“å…¥å±äºå“ªä¸€ç±»ï¼Œä»…è¾“å‡ºJSONï¼š
{{
    "intent": "èŠå¤©/çŸ¥è¯†é—®ç­”/å·¥å…·è°ƒç”¨/å¤æ‚ä»»åŠ¡/æœªçŸ¥",
    "need_memory": true/false,
    "need_knowledge": true/false,
    "need_tool": true/false,
    "need_plan": true/false
}}

ç”¨æˆ·è¾“å…¥ï¼š{user_input}
"""
        try:
            resp = Generation.call(
                model="qwen-turbo",
                api_key=self.api_key,
                messages=[{"role": "user", "content": prompt}],
                result_format="text"
            )
            text = resp.output.text.strip()
            return json.loads(text)
        except:
            return {
                "intent": "æœªçŸ¥",
                "need_memory": False,
                "need_knowledge": False,
                "need_tool": False,
                "need_plan": False
            }
```

---

### 9.3.2 ä»»åŠ¡è§„åˆ’å™¨ï¼ˆè‡ªåŠ¨æ‹†åˆ†å­æ­¥éª¤ï¼‰
```python
# task_planner.py
import json
from dashscope import Generation
from config import DASHSCOPE_API_KEY

class TaskPlanner:
    def __init__(self):
        self.api_key = DASHSCOPE_API_KEY

    def make_plan(self, user_input, intent_info):
        prompt = f"""
ä½ æ˜¯ä»»åŠ¡è§„åˆ’å™¨ï¼Œå°†å¤æ‚ä»»åŠ¡æ‹†åˆ†ä¸ºå­æ­¥éª¤ã€‚
è¾“å‡ºJSONæ ¼å¼ï¼š
{{
    "task": "ä¸»ä»»åŠ¡",
    "steps": [
        {{"step": 1, "action": "åšä»€ä¹ˆ", "tool": "å·¥å…·åæˆ–null", "need_knowledge": true/false}},
        ...
    ],
    "final_summary": "æœ€ç»ˆæ€»ç»“è¦æ±‚"
}}

ç”¨æˆ·ä»»åŠ¡ï¼š{user_input}
æ„å›¾ï¼š{json.dumps(intent_info, ensure_ascii=False)}
"""
        try:
            resp = Generation.call(
                model="qwen-turbo",
                api_key=self.api_key,
                messages=[{"role": "user", "content": prompt}],
                result_format="text"
            )
            return json.loads(resp.output.text)
        except:
            return {
                "task": user_input,
                "steps": [{"step": 1, "action": "ç›´æ¥å›ç­”", "tool": None, "need_knowledge": False}],
                "final_summary": "æ€»ç»“ç»“æœ"
            }
```

---

### 9.3.3 æ¡ä»¶è·¯ç”±ï¼ˆæ ¸å¿ƒå¤§è„‘ï¼‰
```python
# condition_router.py
class ConditionRouter:
    def __init__(self, agent):
        self.agent = agent  # ä¼ å…¥RAGæ™ºèƒ½ä½“

    def route(self, intent, step_action=None):
        if intent["need_plan"] and step_action:
            return "execute_plan_step"

        if intent["need_tool"]:
            return "call_tool"

        if intent["need_knowledge"]:
            return "retrieve_knowledge"

        if intent["need_memory"]:
            return "retrieve_memory"

        return "chat_only"
```

---

### 9.3.4 æ‰§è¡Œå™¨
```python
# executor.py
class Executor:
    def __init__(self, agent):
        self.agent = agent

    def execute_step(self, step):
        action = step["action"]
        tool = step.get("tool")
        need_knowledge = step.get("need_knowledge", False)

        if need_knowledge:
            knowledge = self.agent.knowledge_manager.search_knowledge(action)
        else:
            knowledge = ""

        if tool and tool in self.agent.tool_map:
            res = self.agent.tool_map[tool](action)
        else:
            res = self.agent.call_llm(f"{action}\nå‚è€ƒçŸ¥è¯†ï¼š{knowledge}")

        return f"æ­¥éª¤ç»“æœï¼š{res}"
```

---

### 9.3.5 åæ€æ ¡éªŒå™¨
```python
# reflector.py
from dashscope import Generation
from config import DASHSCOPE_API_KEY

class Reflector:
    def __init__(self):
        self.api_key = DASHSCOPE_API_KEY

    def reflect(self, task, steps_result):
        prompt = f"""
åˆ¤æ–­ä»¥ä¸‹ä»»åŠ¡æ‰§è¡Œç»“æœæ˜¯å¦åˆç†ï¼Œè¾“å‡ºJSONï¼š
{{
    "is_valid": true/false,
    "reason": "åŸå› ",
    "need_retry": false,
    "suggestion": "ä¼˜åŒ–å»ºè®®"
}}

ä»»åŠ¡ï¼š{task}
æ‰§è¡Œç»“æœï¼š{steps_result}
"""
        try:
            resp = Generation.call(
                model="qwen-turbo",
                api_key=self.api_key,
                messages=[{"role": "user", "content": prompt}],
                result_format="text"
            )
            return resp.output.text
        except:
            return '{"is_valid":true,"reason":"æ­£å¸¸","need_retry":false,"suggestion":""}'
```

---

## 9.4 æœ€å¼ºä¸»ä½“ï¼šWorkflowAgentï¼ˆæ•´åˆå…¨éƒ¨èƒ½åŠ›ï¼‰
åœ¨ä½ ä¹‹å‰ `agent_rag.py` çš„åŸºç¡€ä¸Šï¼Œ**ç›´æ¥å‡çº§ä¸ºå·¥ä½œæµæ™ºèƒ½ä½“**ï¼š

```python
# agent_workflow.py
from agent_rag import RAGEnabledAgent
from intent_classifier import IntentClassifier
from task_planner import TaskPlanner
from condition_router import ConditionRouter
from executor import Executor
from reflector import Reflector

class WorkflowAgent(RAGEnabledAgent):
    def __init__(self, user_id="default_user"):
        super().__init__(user_id)
        self.intent_classifier = IntentClassifier()
        self.task_planner = TaskPlanner()
        self.router = ConditionRouter(self)
        self.executor = Executor(self)
        self.reflector = Reflector()

    def run_workflow(self, user_input):
        # ========== 1. æ„å›¾è¯†åˆ« ==========
        intent = self.intent_classifier.classify(user_input)
        print(f"\nğŸ“Œ æ„å›¾è¯†åˆ«ï¼š{intent}")

        # ========== 2. ä»»åŠ¡è§„åˆ’ ==========
        plan = self.task_planner.make_plan(user_input, intent)
        print(f"\nğŸ“‹ ä»»åŠ¡è§„åˆ’ï¼š{plan['task']}")
        for s in plan["steps"]:
            print(f"  Step{s['step']}: {s['action']}")

        # ========== 3. æŒ‰æ­¥éª¤æ‰§è¡Œ ==========
        step_results = []
        for step in plan["steps"]:
            print(f"\nâ–¶ æ‰§è¡Œï¼š{step['action']}")
            res = self.executor.execute_step(step)
            step_results.append(res)
            print(res)

        # ========== 4. åæ€æ ¡éªŒ ==========
        reflect_result = self.reflector.reflect(user_input, step_results)
        print(f"\nâœ… åæ€ç»“æœï¼š{reflect_result}")

        # ========== 5. ç”Ÿæˆæœ€ç»ˆå›ç­” ==========
        final_prompt = f"""
ä»»åŠ¡ï¼š{user_input}
æ‰§è¡Œæ­¥éª¤ï¼š{step_results}
è¯·ç»™å‡ºæœ€ç»ˆæ€»ç»“å›ç­”ã€‚
"""
        final_answer = self.call_llm(final_prompt)

        # ========== 6. ä¿å­˜è®°å¿† ==========
        self.add_structured_memory(user_input, final_answer)

        return final_answer
```

---

## 9.5 è¿è¡Œå…¥å£ï¼ˆmain_workflow.pyï¼‰
```python
# main_workflow.py
from agent_workflow import WorkflowAgent
from knowledge_manager import KnowledgeManager

if __name__ == "__main__":
    agent = WorkflowAgent(user_id="workflow_user_01")
    km = agent.knowledge_manager

    print("===== å·¥ä½œæµæ™ºèƒ½ä½“ï¼ˆç¬¬9ç« ï¼‰=====")
    print("æ”¯æŒï¼šå¤æ‚ä»»åŠ¡è‡ªåŠ¨æ‹†è§£ã€æ¡ä»¶åˆ¤æ–­ã€åæ€")
    print("è¾“å…¥ exit é€€å‡º")

    while True:
        user_input = input("\nè¯·è¾“å…¥ä»»åŠ¡ï¼š")
        if user_input.lower() == "exit":
            break
        answer = agent.run_workflow(user_input)
        print(f"\nğŸ‰ æœ€ç»ˆå›ç­”ï¼š\n{answer}")
```

---

## 9.6 æœ¬ç« å¯ç›´æ¥æµ‹è¯•çš„è¶…å¼ºç¤ºä¾‹
### ä»»åŠ¡1ï¼šå¤æ‚æŸ¥è¯¢ï¼ˆè‡ªåŠ¨æ‹†åˆ†ä¸ºâ€œæŸ¥çŸ¥è¯†+æŸ¥å¤©æ°”+æ€»ç»“â€ï¼‰
```
å¸®æˆ‘åˆ†æåŒ—äº¬ä»Šå¤©æ˜¯å¦é€‚åˆå‡ºè¡Œï¼Œè¦ç»“åˆå¤©æ°”å’Œæ–‡æ¡£é‡Œçš„å»ºè®®
```

**æ‰§è¡Œæµç¨‹ï¼š**
1. æ„å›¾ï¼šå¤æ‚ä»»åŠ¡
2. è§„åˆ’ï¼š
   - æŸ¥å¤©æ°”
   - æŸ¥çŸ¥è¯†åº“ï¼ˆå‡ºè¡Œå»ºè®®ï¼‰
   - æ€»ç»“
3. è‡ªåŠ¨è°ƒç”¨å·¥å…·
4. åæ€æ˜¯å¦åˆç†
5. è¾“å‡ºæœ€ç»ˆç»“è®º

---

### ä»»åŠ¡2ï¼šå¤šæ­¥éª¤è®¡ç®—
```
å…ˆç®—1+2ï¼Œå†ä¹˜ä»¥5ï¼Œæœ€åå‘Šè¯‰æˆ‘ç»“æœæ˜¯å¦åˆç†
```

**æ‰§è¡Œæµç¨‹ï¼š**
1. æ‹†åˆ†å­ä»»åŠ¡
2. è°ƒç”¨è®¡ç®—å™¨
3. åæ€æ ¡éªŒ
4. ç»™å‡ºç»“è®º

---

## 9.7 æœ¬ç« æ€»ç»“ï¼ˆå¯å†™è¿›ä¹¦é‡Œï¼‰
ç¬¬9ç« çœŸæ­£è®©æ™ºèƒ½ä½“æ‹¥æœ‰**å¤§è„‘**ï¼š
- **æ„å›¾è¯†åˆ«**ï¼šçŸ¥é“ç”¨æˆ·è¦ä»€ä¹ˆ
- **ä»»åŠ¡è§„åˆ’**ï¼šè‡ªåŠ¨æ‹†åˆ†å­æ­¥éª¤
- **æ¡ä»¶è·¯ç”±**ï¼šæ™ºèƒ½é€‰æ‹©èƒ½åŠ›
- **æ‰§è¡Œå™¨**ï¼šå¯é è°ƒç”¨å·¥å…·/çŸ¥è¯†åº“
- **åæ€**ï¼šä¿è¯å›ç­”è´¨é‡

**è‡³æ­¤ï¼Œä½ å·²ç»æ‹¥æœ‰å·¥ä¸šçº§æ ‡å‡†çš„ï¼š**
> è®°å¿† + RAGçŸ¥è¯†åº“ + å·¥å…·è°ƒç”¨ + å·¥ä½œæµè§„åˆ’ = å®Œæ•´ autonomous agent

---
